!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).STLParserLib={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}function r(e){return new s(e)}function n(e,t){if("string"==typeof e)if("undefined"!=typeof window){const n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{const e=r(n.response);t(e)},n.send()}else import("fs").then((n=>{const s=n.readFileSync(e);t(r(s))}));else{const n=new FileReader;n.onload=()=>{const e=r(n.result);t(e)},n.readAsArrayBuffer(e)}}class s{constructor(e){"string"!=typeof e&&(e=e.buffer?new Uint8Array(e).buffer:e);const t=s._ensureBinary(e),{vertices:r,faceNormals:n,faceColors:o}=s._isBinary(t)?s._parseBinary(t):s._parseASCII(s._ensureString(e));this._vertices=r,this.faceNormals=n,this.faceColors=o}static _parseBinary(e){const t=new DataView(e),r=t.getUint32(80,!0);let n,s=!1,o=0,i=0,a=0;for(let e=0;e<70;e++)1129270351==t.getUint32(e,!1)&&82==t.getUint8(e+4)&&61==t.getUint8(e+5)&&(s=!0,n=new Float32Array(3*r),o=t.getUint8(e+6)/255,i=t.getUint8(e+7)/255,a=t.getUint8(e+8)/255);const c=new Float32Array(3*r*3),l=new Float32Array(3*r);for(let e=0;e<r;e++){const r=84+50*e,f=3*e;if(l[f]=t.getFloat32(r,!0),l[f+1]=t.getFloat32(r+4,!0),l[f+2]=t.getFloat32(r+8,!0),s){const e=t.getUint16(r+48,!0);0==(32768&e)?(n[f]=(31&e)/31,n[f+1]=(e>>5&31)/31,n[f+2]=(e>>10&31)/31):(n[f]=o,n[f+1]=i,n[f+2]=a)}for(let n=1;n<=3;n++){const s=r+12*n,o=3*e*3+3*(n-1);c[o]=t.getFloat32(s,!0),c[o+1]=t.getFloat32(s+4,!0),c[o+2]=t.getFloat32(s+8,!0)}}return{vertices:c,faceNormals:l,faceColors:n}}static _parseASCII(e){const t=/solid([\s\S]*?)endsolid/g,r=/facet([\s\S]*?)endfacet/g;let n=0;const s=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,o=new RegExp("vertex"+s+s+s,"g"),i=new RegExp("normal"+s+s+s,"g"),a=[],c=[];let l;for(;null!==(l=t.exec(e));){const e=l[0];for(;null!==(l=r.exec(e));){let e=0,t=0;const r=l[0];for(;null!==(l=i.exec(r));){if(t>0)throw new Error("stl-parser: Something isn't right with the normal of face number "+n);c.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3])),t++}for(;null!==(l=o.exec(r));)a.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3])),e++;if(3!==e)throw new Error("stl-parser: Something isn't right with the vertices of face number "+n);n++}}return{vertices:new Float32Array(a),faceNormals:new Float32Array(c)}}static _matchDataViewAt(e,t,r){for(let n=0,s=e.length;n<s;n++)if(e[n]!==t.getUint8(r+n))return!1;return!0}static _isBinary(e){const t=new DataView(e);if(84+50*t.getUint32(80,!0)===t.byteLength)return!0;const r=[115,111,108,105,100];for(let e=0;e<5;e++)if(s._matchDataViewAt(r,t,e))return!1;return!0}static _ensureBinary(e){if("string"==typeof e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=255&e.charCodeAt(r);return t.buffer||t}return e}static _ensureString(e){return"string"!=typeof e?(new TextDecoder).decode(e):e}get vertices(){return this._vertices}set vertices(e){throw new Error("stl-parser: No vertices setter.")}get faceIndices(){if(!this._faceIndices)throw new Error("stl-parser: STL vertices are non-indexed by default, call STLMesh.mergeVertices() before trying to access faceIndices.");return this._faceIndices}set faceIndices(e){throw new Error("stl-parser: No faceIndices setter.")}mergeVertices(){const{verticesMerged:e,facesIndexed:t}=function(e){const{vertices:t,uvs:r,vertexNormals:n,vertexColors:s}=e,o=t.length/9,i=[],a=new Uint32Array(3*o),c={};for(let e=0;e<o;e++)for(let o=0;o<3;o++){const l=3*e+o;let f=`${t[3*l]},${t[3*l+1]},${t[3*l+2]}`;r&&(f+=`|${r[2*l]},${r[2*l+1]}`),n&&(f+=`|${n[3*l]},${n[3*l+1]},${n[3*l+2]}`),s&&(f+=`|${s[3*l]},${s[3*l+1]},${s[3*l+2]}`);const d=3*e;let u=c[f];void 0!==u?a[d+o]=u:(u=i.length,a[d+o]=u,c[f]=u,i.push(l))}const l=i.length,f=new Float32Array(3*l);for(let e=0;e<l;e++){const r=i[e];f[3*e]=t[3*r],f[3*e+1]=t[3*r+1],f[3*e+2]=t[3*r+2]}let d,u,g;if(r){d=new Float32Array(2*l);for(let e=0;e<l;e++){const t=i[e];d[2*e]=r[2*t],d[2*e+1]=r[2*t+1]}}if(n){u=new Float32Array(3*l);for(let e=0;e<l;e++){const t=i[e];u[3*e]=n[3*t],u[3*e+1]=n[3*t+1],u[3*e+2]=n[3*t+2]}}if(s){g=new Float32Array(3*l);for(let e=0;e<l;e++){const t=i[e];g[3*e]=s[3*t],g[3*e+1]=s[3*t+1],g[3*e+2]=s[3*t+2]}}return{verticesMerged:f,uvsMerged:d,vertexNormalsMerged:u,vertexColorsMerged:g,facesIndexed:a}}(this);return this._vertices=new Float32Array(e),this._faceIndices=t,delete this._edgeIndices,this}get edgeIndices(){if(!this._edgeIndices){const{_faceIndices:e}=this;let r;r=e?new Uint32Array(function(e){const{faceIndices:r}=e,n=r.length/3,s={},o=[];for(let e=0;e<n;e++)for(let n=0;n<3;n++){const i=r[3*e+n],a=r[3*e+(n+1)%3],c=t(i,a);void 0===s[c]&&(s[c]=!0,o.push(i,a))}return o}(this)):function(e){const{vertices:t}=e,r=t.length/3/3,n=new Uint32Array(6*r);for(let e=0;e<r;e++){const t=3*e;for(let r=0;r<3;r++){const s=6*e+2*r;n[s]=t+r,n[s+1]=t+(r+1)%3}}return n}(this),this._edgeIndices=r}return this._edgeIndices}set edgeIndices(e){throw new Error("stl-parser: No edgeIndices setter.")}get boundingBox(){return this._boundingBox||(this._boundingBox=function(e){const{vertices:t}=e,r=t.length/3,n=[1/0,1/0,1/0],s=[-1/0,-1/0,-1/0];for(let e=0;e<r;e++)n[0]=Math.min(n[0],t[3*e]),n[1]=Math.min(n[1],t[3*e+1]),n[2]=Math.min(n[2],t[3*e+2]),s[0]=Math.max(s[0],t[3*e]),s[1]=Math.max(s[1],t[3*e+1]),s[2]=Math.max(s[2],t[3*e+2]);return{min:n,max:s}}(this)),this._boundingBox}set boundingBox(e){throw new Error("stl-parser: No boundingBox setter.")}scaleVerticesToUnitBoundingBox(){return function(e,t=e.vertices){const{vertices:r,boundingBox:n}=e,{min:s,max:o}=n,i=[o[0]-s[0],o[1]-s[1],o[2]-s[2]],a=[(o[0]+s[0])/2,(o[1]+s[1])/2,(o[2]+s[2])/2],c=Math.max(i[0],i[1],i[2]),l=r.length/3;for(let e=0;e<l;e++)for(let n=0;n<3;n++)t[3*e+n]=(r[3*e+n]-a[n])/c}(this),delete this._boundingBox,this}}e.loadSTL=n,e.loadSTLAsync=function(e){return new Promise((t=>{n(e,(e=>{t(e)}))}))},e.parseSTL=r}));
//# sourceMappingURL=stl-parser.min.js.map
