{"version":3,"file":"stl-parser.min.js","sources":["../src/stl-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/3d-mesh-utils.js"],"sourcesContent":["import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgesFromIndexedFaces,\n\tcalcEdgesFromNonIndexedFaces,\n\tmergeVertices,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .stl file buffer or string.\n */\nexport function parseSTL(data: Buffer | ArrayBuffer | string): STLMesh {\n\treturn new _STLMesh(data);\n}\n\n/**\n * Load and parse the .stl asynchronously from a specified url or File object (returns Promise).\n */\nexport function loadSTLAsync(urlOrFile: string | File) {\n\treturn new Promise<STLMesh>((resolve) => {\n\t\tloadSTL(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse the .stl from a specified url or File object.\n */\nexport function loadSTL(urlOrFile: string | File, callback: (mesh: STLMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\tif (typeof window !== 'undefined') {\n\t\t\t/* c8 ignore start */\n\t\t\t// Browser.\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseSTL(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Nodejs.\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseSTL(buffer));\n\t\t\t});\n\t\t}\n\t} else {\n\t\t/* c8 ignore start */\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseSTL(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile as File);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type STLMesh = {\n\treadonly vertices: Float32Array | number[];\n\treadonly faceNormals: Float32Array | number[];\n\treadonly edges: Uint32Array | number[];\n\treadonly faceColors?: Float32Array;\n\treadonly faceIndices: Uint32Array;\n\treadonly boundingBox: { min:number[], max: number[] };\n\tmergeVertices: () => STLMesh;\n\tscaleVerticesToUnitBoundingBox: () => STLMesh;\n}\n\n// Based on: https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/STLLoader.js\n// Define the STLMesh class.\nclass _STLMesh {\n\tprivate _vertices: Float32Array | number[];\n\treadonly faceNormals: Float32Array | number[];\n\treadonly faceColors?: Float32Array;\n\tprivate _faceIndices?: Uint32Array;\n\tprivate _edges?: Uint32Array | number[];\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\n\tconstructor(data: Buffer | ArrayBuffer | string) {\n\t\tif (typeof data !== 'string') {\n\t\t\tdata = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\t}\n\t\tconst binData = _STLMesh._ensureBinary(data);\n\t\tconst { vertices, faceNormals, faceColors } = _STLMesh._isBinary(binData) ?\n\t\t\t_STLMesh._parseBinary(binData) :\n\t\t\t_STLMesh._parseASCII(_STLMesh._ensureString(data)) as { vertices: number[], faceNormals: number[], faceColors?: Float32Array };\n\t\t\n\t\tthis._vertices = vertices;\n\t\tthis.faceNormals = faceNormals;\n\t\tthis.faceColors = faceColors;\n\t}\n\n\t// Parsing code is based on:\n\t// https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/STLLoader.js\n\tprivate static _parseBinary(data: ArrayBuffer) {\n\t\tconst reader = new DataView(data);\n\t\tconst numFaces = reader.getUint32(80, true);\n\n\t\tlet hasColors = false;\n\t\tlet faceColors: Float32Array | undefined;\n\t\tlet defaultR = 0;\n\t\tlet defaultG = 0;\n\t\tlet defaultB = 0;\n\t\t// let alpha: number;\n\n\t\t// process STL header\n\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\t\tfor (let index = 0; index < 80 - 10; index++) {\n\t\t\tif ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&\n\t\t\t\t(reader.getUint8(index + 4) == 0x52 /*'R'*/) &&\n\t\t\t\t(reader.getUint8(index + 5) == 0x3D /*'='*/)) {\n\n\t\t\t\thasColors = true;\n\t\t\t\tfaceColors = new Float32Array(numFaces * 3);\n\n\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;\n\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;\n\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;\n\t\t\t\t// alpha = reader.getUint8(index + 9) / 255;\n\t\t\t}\n\t\t}\n\n\t\tconst dataOffset = 84;\n\t\tconst faceLength = 12 * 4 + 2;\n\n\t\tconst vertices = new Float32Array(numFaces * 3 * 3);\n\t\tconst faceNormals = new Float32Array(numFaces * 3);\n\n\t\tfor (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {\n\t\t\tconst start = dataOffset + faceIndex * faceLength;\n\t\t\tconst index = 3 * faceIndex;\n\t\t\tfaceNormals[index] = reader.getFloat32(start, true);\n\t\t\tfaceNormals[index + 1] = reader.getFloat32(start + 4, true);\n\t\t\tfaceNormals[index + 2] = reader.getFloat32(start + 8, true);\n\n\t\t\tif (hasColors) {\n\t\t\t\tconst packedColor = reader.getUint16(start + 48, true);\n\t\t\t\tif ((packedColor & 0x8000) === 0) {\n\t\t\t\t\t// facet has its own unique color\n\t\t\t\t\tfaceColors![index] = (packedColor & 0x1F) / 31;\n\t\t\t\t\tfaceColors![index + 1] = ((packedColor >> 5) & 0x1F) / 31;\n\t\t\t\t\tfaceColors![index + 2] = ((packedColor >> 10) & 0x1F) / 31;\n\t\t\t\t} else {\n\t\t\t\t\tfaceColors![index] = defaultR;\n\t\t\t\t\tfaceColors![index + 1] = defaultG;\n\t\t\t\t\tfaceColors![index + 2] = defaultB;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 1; i <= 3; i++) {\n\t\t\t\tconst vertexStart = start + i * 12;\n\t\t\t\tconst componentIndex = (faceIndex * 3 * 3) + ((i - 1) * 3);\n\t\t\t\tvertices[componentIndex] = reader.getFloat32(vertexStart, true);\n\t\t\t\tvertices[componentIndex + 1] = reader.getFloat32(vertexStart + 4, true);\n\t\t\t\tvertices[componentIndex + 2] = reader.getFloat32(vertexStart + 8, true);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvertices,\n\t\t\tfaceNormals,\n\t\t\tfaceColors,\n\t\t};\n\t}\n\n\tprivate static _parseASCII(data: string) {\n\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\tlet faceCounter = 0;\n\n\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\tconst patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n\t\tconst patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n\n\t\tconst vertices: number[] = [];\n\t\tconst faceNormals: number[] = [];\n\n\t\tlet result;\n\n\t\twhile ((result = patternSolid.exec(data)) !== null) {\n\t\t\tconst solid = result[0];\n\n\t\t\twhile ((result = patternFace.exec(solid)) !== null ) {\n\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\tconst text = result[0];\n\n\t\t\t\twhile ((result = patternNormal.exec(text)) !== null) {\n\t\t\t\t\t// every face have to own ONE valid normal\n\t\t\t\t\tif (normalCountPerFace > 0) throw new Error('stl-parser: Something isn\\'t right with the normal of face number ' + faceCounter);\n\t\t\t\t\tfaceNormals.push(\n\t\t\t\t\t\tparseFloat(result[1]),\n\t\t\t\t\t\tparseFloat(result[2]),\n\t\t\t\t\t\tparseFloat(result[3]),\n\t\t\t\t\t);\n\t\t\t\t\tnormalCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\twhile ((result = patternVertex.exec(text)) !== null) {\n\t\t\t\t\tvertices.push(\n\t\t\t\t\t\tparseFloat(result[1]),\n\t\t\t\t\t\tparseFloat(result[2]),\n\t\t\t\t\t\tparseFloat(result[3]),\n\t\t\t\t\t);\n\t\t\t\t\tvertexCountPerFace++;\n\t\t\t\t}\n\t\t\t\t// Each face have to own THREE valid vertices\n\t\t\t\t/* c8 ignore start */\n\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\t\t\t\t\tthrow new Error('stl-parser: Something isn\\'t right with the vertices of face number ' + faceCounter);\n\t\t\t\t}\n\t\t\t\t/* c8 ignore stop */\n\n\t\t\t\tfaceCounter++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvertices,\n\t\t\tfaceNormals,\n\t\t};\n\t}\n\n\tprivate static _matchDataViewAt(query: number[], reader: DataView, offset: number) {\n\t\t// Check if each byte in query matches the corresponding byte from the current offset.\n\t\tfor (let i = 0, il = query.length; i < il; i++) {\n\t\t\tif (query[i] !== reader.getUint8(offset + i)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _isBinary(data: ArrayBuffer) {\n\t\tconst reader = new DataView(data);\n\t\tconst face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n\t\tconst n_faces = reader.getUint32(80, true);\n\t\tconst expect = 80 + (32 / 8) + (n_faces * face_size);\n\t\tif (expect === reader.byteLength) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\t\tconst solid = [115, 111, 108, 105, 100];\n\t\tfor (let offset = 0; offset < 5; offset++) {\n\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\t\t\tif (_STLMesh._matchDataViewAt(solid, reader, offset)) return false;\n\t\t}\n\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\t\treturn true;\n\t}\n\n\tprivate static _ensureBinary(buffer: ArrayBuffer | string) {\n\t\tif (typeof buffer === 'string') {\n\t\t\tconst array_buffer = new Uint8Array(buffer.length);\n\t\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\t\t\t}\n\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t} else {\n\t\t\treturn buffer;\n\t\t}\n\t}\n\n\tprivate static _ensureString(buffer: ArrayBuffer | string) {\n\t\tif (typeof buffer !== 'string') {\n\t\t\treturn new TextDecoder().decode(buffer);\n\t\t}\n\t\treturn buffer;\n\t}\n\n\tget vertices() {\n\t\treturn this._vertices;\n\t}\n\n\t/* c8 ignore start */\n\tset vertices(vertices: Float32Array | number[]) {\n\t\tthrow new Error(`No vertices setter.`);\n\t}\n\t/* c8 ignore stop */\n\n\tget faceIndices() {\n\t\tif (!this._faceIndices) throw new Error(`stl-parser: Call STLMesh.mergeVertices() before trying to access faceIndices.`);\n\t\treturn this._faceIndices;\n\t}\n\n\t/* c8 ignore start */\n\tset faceIndices(faceIndices: Uint32Array) {\n\t\tthrow new Error(`No faceIndices setter.`);\n\t}\n\t/* c8 ignore stop */\n\n\t/**\n\t * Merge coincident vertices and index faces.\n\t */\n\tmergeVertices() {\n\t\tconst {\n\t\t\tverticesMerged,\n\t\t\tfacesIndexed,\n\t\t} = mergeVertices(this);\n\t\tthis._vertices = verticesMerged;\n\t\tthis._faceIndices = facesIndexed;\n\t\tdelete this._edges; // Invalidate previously calculated edges.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the edges in the stl data (without duplicates).\n\t */\n\tget edges() {\n\t\tif (!this._edges) {\n\t\t\tconst { _faceIndices } = this;\n\t\t\tlet edges: Uint32Array | number[];\n\t\t\tif (_faceIndices) {\n\t\t\t\t// Handle edges on indexed faces.\n\t\t\t\tedges = calcEdgesFromIndexedFaces(this);\n\t\t\t} else {\n\t\t\t\t// Vertices are grouped in sets of three to a face.\n\t\t\t\tedges = calcEdgesFromNonIndexedFaces(this);\n\t\t\t}\n\t\t\tthis._edges = edges; // Cache result.\n\t\t}\n\t\treturn this._edges;\n\t}\n\n\t/* c8 ignore start */\n\tset edges(edges: Uint32Array | number[]) {\n\t\tthrow new Error(`No edges setter.`);\n\t}\n\t/* c8 ignore stop */\n\n\t/**\n\t * Returns the bounding box of the mesh.\n\t */\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\t // Cache result.\n\t\t\tthis._boundingBox = calcBoundingBox(this);\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\t/* c8 ignore start */\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`No boundingBox setter.`);\n\t}\n\t/* c8 ignore stop */\n\n\t/**\n\t * Scales vertex positions (in place) to unit bounding box and centers around origin.\n\t */\n\tscaleVerticesToUnitBoundingBox() {\n\t\t// Scale vertices to bounding box (in place).\n\t\tscaleVerticesToUnitBoundingBox(this);\n\t\tdelete this._boundingBox; // Invalidate previously calculated bounding box.\n\t\treturn this;\n\t}\n}","/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesFromNestedIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = faceIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesFromIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = faceIndices[3 * i + j];\n            const index2 = faceIndices[3 * i + (j + 1) % 3];\n            const key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices } = mesh;\n    const numFaces = vertices.length / 9;\n    const verticesMerged = [];\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 9 * i + 3 * j;\n            const faceIndex = 3 * i;\n            const positionX = vertices[vertexIndex];\n            const positionY = vertices[vertexIndex + 1];\n            const positionZ = vertices[vertexIndex + 2];\n            const key = `${positionX},${positionY},${positionZ}`;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = verticesMerged.length / 3;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                verticesMerged.push(positionX, positionY, positionZ);\n            }\n        }\n    }\n    return {\n        verticesMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=3d-mesh-utils.js.map"],"names":["parseSTL","data","_STLMesh","loadSTL","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","Uint8Array","binData","_ensureBinary","vertices","faceNormals","faceColors","_isBinary","_parseBinary","_parseASCII","_ensureString","this","_vertices","static","DataView","numFaces","getUint32","hasColors","defaultR","defaultG","defaultB","index","getUint8","Float32Array","faceIndex","start","getFloat32","packedColor","getUint16","i","vertexStart","componentIndex","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","exec","solid","vertexCountPerFace","normalCountPerFace","text","Error","push","parseFloat","query","offset","il","length","byteLength","_matchDataViewAt","array_buffer","charCodeAt","TextDecoder","decode","faceIndices","_faceIndices","mergeVertices","verticesMerged","facesIndexed","Uint32Array","vertexHash","j","vertexIndex","positionX","positionY","positionZ","key","mergedVertexIndex","undefined","_edges","edges","edgesHash","index1","index2","Math","min","max","calcEdgesFromIndexedFaces","edgeIndex","calcEdgesFromNonIndexedFaces","boundingBox","_boundingBox","numVertices","Infinity","calcBoundingBox","scaleVerticesToUnitBoundingBox","target","diff","center","scale","numNodes","Promise","resolve"],"mappings":"oPAWM,SAAUA,EAASC,GACxB,OAAO,IAAIC,EAASD,EACrB,CAgBgB,SAAAE,EAAQC,EAA0BC,GACjD,GAAyB,iBAAdD,EAEV,GAAsB,oBAAXE,OAAwB,CAIlC,MAAMC,EAAU,IAAIC,eACpBD,EAAQE,KAAK,MAAOL,GAAW,GAC/BG,EAAQG,aAAe,cACvBH,EAAQI,OAAS,KAChB,MAAMC,EAAOZ,EAASO,EAAQM,UAE9BR,EAASO,EAAK,EAEfL,EAAQO,MAER,MAGAC,OAAO,MAAMC,MAAMC,IAClB,MAAMC,EAASD,EAAGE,aAAaf,GAC/BC,EAASL,EAASkB,GAAQ,QAGtB,CAIN,MAAME,EAAS,IAAIC,WACnBD,EAAOT,OAAS,KACf,MAAMC,EAAOZ,EAASoB,EAAOE,QAE7BjB,EAASO,EAAK,EAEfQ,EAAOG,kBAAkBnB,EACzB,CAEF,CAgBA,MAAMF,EAQLsB,YAAYvB,GACS,iBAATA,IACVA,EAAQA,EAAgBiB,OAAS,IAAIO,WAAWxB,GAAgBiB,OAASjB,GAE1E,MAAMyB,EAAUxB,EAASyB,cAAc1B,IACjC2B,SAAEA,EAAQC,YAAEA,EAAWC,WAAEA,GAAe5B,EAAS6B,UAAUL,GAChExB,EAAS8B,aAAaN,GACtBxB,EAAS+B,YAAY/B,EAASgC,cAAcjC,IAE7CkC,KAAKC,UAAYR,EACjBO,KAAKN,YAAcA,EACnBM,KAAKL,WAAaA,CAClB,CAIOO,oBAAoBpC,GAC3B,MAAMmB,EAAS,IAAIkB,SAASrC,GACtBsC,EAAWnB,EAAOoB,UAAU,IAAI,GAEtC,IACIV,EADAW,GAAY,EAEZC,EAAW,EACXC,EAAW,EACXC,EAAW,EAKf,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,GAASA,IACG,YAAlCzB,EAAOoB,UAAUK,GAAO,IACG,IAA9BzB,EAAO0B,SAASD,EAAQ,IACM,IAA9BzB,EAAO0B,SAASD,EAAQ,KAEzBJ,GAAY,EACZX,EAAa,IAAIiB,aAAwB,EAAXR,GAE9BG,EAAWtB,EAAO0B,SAASD,EAAQ,GAAK,IACxCF,EAAWvB,EAAO0B,SAASD,EAAQ,GAAK,IACxCD,EAAWxB,EAAO0B,SAASD,EAAQ,GAAK,KAK1C,MAGMjB,EAAW,IAAImB,aAAwB,EAAXR,EAAe,GAC3CV,EAAc,IAAIkB,aAAwB,EAAXR,GAErC,IAAK,IAAIS,EAAY,EAAGA,EAAYT,EAAUS,IAAa,CAC1D,MAAMC,EAPY,GACA,GAMSD,EACrBH,EAAQ,EAAIG,EAKlB,GAJAnB,EAAYgB,GAASzB,EAAO8B,WAAWD,GAAO,GAC9CpB,EAAYgB,EAAQ,GAAKzB,EAAO8B,WAAWD,EAAQ,GAAG,GACtDpB,EAAYgB,EAAQ,GAAKzB,EAAO8B,WAAWD,EAAQ,GAAG,GAElDR,EAAW,CACd,MAAMU,EAAc/B,EAAOgC,UAAUH,EAAQ,IAAI,GAClB,IAAZ,MAAdE,IAEJrB,EAAYe,IAAwB,GAAdM,GAAsB,GAC5CrB,EAAYe,EAAQ,IAAOM,GAAe,EAAK,IAAQ,GACvDrB,EAAYe,EAAQ,IAAOM,GAAe,GAAM,IAAQ,KAExDrB,EAAYe,GAASH,EACrBZ,EAAYe,EAAQ,GAAKF,EACzBb,EAAYe,EAAQ,GAAKD,EAE1B,CAED,IAAK,IAAIS,EAAI,EAAGA,GAAK,EAAGA,IAAK,CAC5B,MAAMC,EAAcL,EAAY,GAAJI,EACtBE,EAA8B,EAAZP,EAAgB,EAAgB,GAATK,EAAI,GACnDzB,EAAS2B,GAAkBnC,EAAO8B,WAAWI,GAAa,GAC1D1B,EAAS2B,EAAiB,GAAKnC,EAAO8B,WAAWI,EAAc,GAAG,GAClE1B,EAAS2B,EAAiB,GAAKnC,EAAO8B,WAAWI,EAAc,GAAG,EAClE,CACD,CAED,MAAO,CACN1B,WACAC,cACAC,aAED,CAEOO,mBAAmBpC,GAC1B,MAAMuD,EAAe,2BACfC,EAAc,2BACpB,IAAIC,EAAc,EAElB,MAAMC,EAAe,iDAAiDC,OAChEC,EAAgB,IAAIC,OAAO,SAAWH,EAAeA,EAAeA,EAAc,KAClFI,EAAgB,IAAID,OAAO,SAAWH,EAAeA,EAAeA,EAAc,KAElF/B,EAAqB,GACrBC,EAAwB,GAE9B,IAAIP,EAEJ,KAA8C,QAAtCA,EAASkC,EAAaQ,KAAK/D,KAAiB,CACnD,MAAMgE,EAAQ3C,EAAO,GAErB,KAA8C,QAAtCA,EAASmC,EAAYO,KAAKC,KAAmB,CACpD,IAAIC,EAAqB,EACrBC,EAAqB,EAEzB,MAAMC,EAAO9C,EAAO,GAEpB,KAA+C,QAAvCA,EAASyC,EAAcC,KAAKI,KAAiB,CAEpD,GAAID,EAAqB,EAAG,MAAM,IAAIE,MAAM,oEAAuEX,GACnH7B,EAAYyC,KACXC,WAAWjD,EAAO,IAClBiD,WAAWjD,EAAO,IAClBiD,WAAWjD,EAAO,KAEnB6C,GACA,CAED,KAA+C,QAAvC7C,EAASuC,EAAcG,KAAKI,KACnCxC,EAAS0C,KACRC,WAAWjD,EAAO,IAClBiD,WAAWjD,EAAO,IAClBiD,WAAWjD,EAAO,KAEnB4C,IAID,GAA4B,IAAvBA,EACJ,MAAM,IAAIG,MAAM,sEAAyEX,GAI1FA,GACA,CACD,CAED,MAAO,CACN9B,WACAC,cAED,CAEOQ,wBAAwBmC,EAAiBpD,EAAkBqD,GAElE,IAAK,IAAIpB,EAAI,EAAGqB,EAAKF,EAAMG,OAAQtB,EAAIqB,EAAIrB,IAC1C,GAAImB,EAAMnB,KAAOjC,EAAO0B,SAAS2B,EAASpB,GAAI,OAAO,EAEtD,OAAO,CACP,CAEOhB,iBAAiBpC,GACxB,MAAMmB,EAAS,IAAIkB,SAASrC,GAI5B,GADe,GAFG,GACFmB,EAAOoB,UAAU,IAAI,KAEtBpB,EAAOwD,WACrB,OAAO,EAYR,MAAMX,EAAQ,CAAC,IAAK,IAAK,IAAK,IAAK,KACnC,IAAK,IAAIQ,EAAS,EAAGA,EAAS,EAAGA,IAEhC,GAAIvE,EAAS2E,iBAAiBZ,EAAO7C,EAAQqD,GAAS,OAAO,EAG9D,OAAO,CACP,CAEOpC,qBAAqBnB,GAC5B,GAAsB,iBAAXA,EAAqB,CAC/B,MAAM4D,EAAe,IAAIrD,WAAWP,EAAOyD,QAC3C,IAAK,IAAItB,EAAI,EAAGA,EAAInC,EAAOyD,OAAQtB,IAClCyB,EAAczB,GAA+B,IAAzBnC,EAAO6D,WAAY1B,GAExC,OAAOyB,EAAa5D,QAAU4D,CAC9B,CACA,OAAO5D,CAER,CAEOmB,qBAAqBnB,GAC5B,MAAsB,iBAAXA,GACH,IAAI8D,aAAcC,OAAO/D,GAE1BA,CACP,CAEGU,eACH,OAAOO,KAAKC,SACZ,CAGGR,aAASA,GACZ,MAAM,IAAIyC,MAAM,sBAChB,CAGGa,kBACH,IAAK/C,KAAKgD,aAAc,MAAM,IAAId,MAAM,iFACxC,OAAOlC,KAAKgD,YACZ,CAGGD,gBAAYA,GACf,MAAM,IAAIb,MAAM,yBAChB,CAMDe,gBACC,MAAMC,eACLA,EAAcC,aACdA,GC7MI,SAAuB1E,GAC1B,MAAMgB,SAAEA,GAAahB,EACf2B,EAAWX,EAAS+C,OAAS,EAC7BU,EAAiB,GACjBC,EAAe,IAAIC,YAAuB,EAAXhD,GAE/BiD,EAAa,CAAA,EACnB,IAAK,IAAInC,EAAI,EAAGA,EAAId,EAAUc,IAC1B,IAAK,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMC,EAAc,EAAIrC,EAAI,EAAIoC,EAC1BzC,EAAY,EAAIK,EAChBsC,EAAY/D,EAAS8D,GACrBE,EAAYhE,EAAS8D,EAAc,GACnCG,EAAYjE,EAAS8D,EAAc,GACnCI,EAAM,GAAGH,KAAaC,KAAaC,IACzC,IAAIE,EAAoBP,EAAWM,QACTE,IAAtBD,EACAT,EAAatC,EAAYyC,GAAKM,GAI9BA,EAAoBV,EAAeV,OAAS,EAC5CW,EAAatC,EAAYyC,GAAKM,EAC9BP,EAAWM,GAAOC,EAClBV,EAAef,KAAKqB,EAAWC,EAAWC,GAEjD,CAEL,MAAO,CACHR,iBACAC,eAER,CD8KMF,CAAcjD,MAIlB,OAHAA,KAAKC,UAAYiD,EACjBlD,KAAKgD,aAAeG,SACbnD,KAAK8D,OACL9D,IACP,CAKG+D,YACH,IAAK/D,KAAK8D,OAAQ,CACjB,MAAMd,aAAEA,GAAiBhD,KACzB,IAAI+D,EAGHA,EAFGf,EC1RA,SAAmCvE,GACtC,MAAMsE,YAAEA,GAAgBtE,EAElB2B,EAAW2C,EAAYP,OAAS,EAEhCwB,EAAY,CAAA,EACZD,EAAQ,GACd,IAAK,IAAI7C,EAAI,EAAGA,EAAId,EAAUc,IAC1B,IAAK,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMW,EAASlB,EAAY,EAAI7B,EAAIoC,GAC7BY,EAASnB,EAAY,EAAI7B,GAAKoC,EAAI,GAAK,GACvCK,EAAM,GAAGQ,KAAKC,IAAIH,EAAQC,MAAWC,KAAKE,IAAIJ,EAAQC,UAErCL,IAAnBG,EAAUL,KACVK,EAAUL,IAAO,EACjBI,EAAM5B,KAAK8B,EAAQC,GAE1B,CAEL,OAAOH,CACX,CDwQYO,CAA0BtE,MCnQ/B,SAAsCvB,GACzC,MAAMgB,SAAEA,GAAahB,EAGf2B,EAFcX,EAAS+C,OAAS,EAEP,EACzBuB,EAAQ,IAAIX,YAAY,EAAIhD,GAClC,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAUc,IAAK,CAC/B,MAAMR,EAAQ,EAAIQ,EAClB,IAAK,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMiB,EAAY,EAAIrD,EAAI,EAAIoC,EAC9BS,EAAMQ,GAAa7D,EAAQ4C,EAC3BS,EAAMQ,EAAY,GAAK7D,GAAS4C,EAAI,GAAK,CAC5C,CACJ,CACD,OAAOS,CACX,CDuPYS,CAA6BxE,MAEtCA,KAAK8D,OAASC,CACd,CACD,OAAO/D,KAAK8D,MACZ,CAGGC,UAAMA,GACT,MAAM,IAAI7B,MAAM,mBAChB,CAMGuC,kBAKH,OAJKzE,KAAK0E,eAET1E,KAAK0E,aClWD,SAAyBjG,GAC5B,MAAMgB,SAAEA,GAAahB,EACfkG,EAAclF,EAAS+C,OAAS,EAChC4B,EAAM,CAACQ,IAAUA,IAAUA,KAC3BP,EAAM,EAAC,KAAW,KAAW,KACnC,IAAK,IAAInD,EAAI,EAAGA,EAAIyD,EAAazD,IAC7BkD,EAAI,GAAKD,KAAKC,IAAIA,EAAI,GAAI3E,EAAS,EAAIyB,IACvCkD,EAAI,GAAKD,KAAKC,IAAIA,EAAI,GAAI3E,EAAS,EAAIyB,EAAI,IAC3CkD,EAAI,GAAKD,KAAKC,IAAIA,EAAI,GAAI3E,EAAS,EAAIyB,EAAI,IAC3CmD,EAAI,GAAKF,KAAKE,IAAIA,EAAI,GAAI5E,EAAS,EAAIyB,IACvCmD,EAAI,GAAKF,KAAKE,IAAIA,EAAI,GAAI5E,EAAS,EAAIyB,EAAI,IAC3CmD,EAAI,GAAKF,KAAKE,IAAIA,EAAI,GAAI5E,EAAS,EAAIyB,EAAI,IAE/C,MAAO,CAAEkD,MAAKC,MAClB,CDoVuBQ,CAAgB7E,OAE9BA,KAAK0E,YACZ,CAGGD,gBAAYA,GACf,MAAM,IAAIvC,MAAM,yBAChB,CAMD4C,iCAIC,OCvRK,SAAwCrG,EAAMsG,EAAStG,EAAKgB,UAC/D,MAAMA,SAAEA,EAAQgF,YAAEA,GAAgBhG,GAC5B2F,IAAEA,EAAGC,IAAEA,GAAQI,EACfO,EAAO,CAACX,EAAI,GAAKD,EAAI,GAAIC,EAAI,GAAKD,EAAI,GAAIC,EAAI,GAAKD,EAAI,IACvDa,EAAS,EAAEZ,EAAI,GAAKD,EAAI,IAAM,GAAIC,EAAI,GAAKD,EAAI,IAAM,GAAIC,EAAI,GAAKD,EAAI,IAAM,GAC5Ec,EAAQf,KAAKE,IAAIW,EAAK,GAAIA,EAAK,GAAIA,EAAK,IACxCG,EAAW1F,EAAS+C,OAAS,EACnC,IAAK,IAAItB,EAAI,EAAGA,EAAIiE,EAAUjE,IAC1B,IAAK,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAEnByB,EAAO,EAAI7D,EAAIoC,IAAM7D,EAAS,EAAIyB,EAAIoC,GAAK2B,EAAO3B,IAAM4B,CAGpE,CDwQEJ,CAA+B9E,aACxBA,KAAK0E,aACL1E,IACP,6BAtWI,SAAuB/B,GAC5B,OAAO,IAAImH,SAAkBC,IAC5BrH,EAAQC,GAAYQ,IACnB4G,EAAQ5G,EAAK,GACZ,GAEJ"}