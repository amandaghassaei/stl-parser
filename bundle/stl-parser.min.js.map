{"version":3,"file":"stl-parser.min.js","sources":["../node_modules/@amandaghassaei/3d-mesh-utils/dist/index-utils.js","../src/stl-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/geometry-utils.js"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1, index2) {\n    return `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1, index2, index3) {\n    const min = Math.min(index1, index2, index3);\n    const max = Math.max(index1, index2, index3);\n    const sum = index1 + index2 + index3;\n    return `${min},${sum - min - max},${max}`;\n}\nlet tempArray = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param facesIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(facesIndices) {\n    const length = facesIndices.length;\n    tempArray.length = length;\n    for (let i = 0; i < length; i++) {\n        tempArray[i] = facesIndices[i];\n    }\n    tempArray.sort((a, b) => (a - b));\n    return tempArray.join(',');\n}\n//# sourceMappingURL=index-utils.js.map","import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgeIndicesFromIndexedFaces,\n\tcalcEdgeIndicesFromNonIndexedFaces,\n\tmergeVertices,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .stl file buffer or string.\n */\nexport function parseSTL(data: Buffer | ArrayBuffer | string): STLMesh {\n\treturn new _STLMesh(data);\n}\n\n/**\n * Load and parse the .stl asynchronously from a specified url or File object (returns Promise).\n */\nexport function loadSTLAsync(urlOrFile: string | File) {\n\treturn new Promise<STLMesh>((resolve) => {\n\t\tloadSTL(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse the .stl from a specified url or File object.\n */\nexport function loadSTL(urlOrFile: string | File, callback: (mesh: STLMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\t/* c8 ignore start */\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Browser.\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseSTL(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Nodejs.\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseSTL(buffer));\n\t\t\t});\n\t\t}\n\t/* c8 ignore start */\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseSTL(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile as File);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type STLMesh = {\n\treadonly vertices: Float32Array;\n\treadonly faceNormals: Float32Array;\n\treadonly edgeIndices: Uint32Array;\n\treadonly faceColors?: Float32Array;\n\treadonly facesIndices: Uint32Array;\n\treadonly boundingBox: { min: [number, number, number], max: [number, number, number] };\n\tmergeVertices: () => STLMesh;\n\tscaleVerticesToUnitBoundingBox: () => STLMesh;\n}\n\n// Based on: https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/STLLoader.js\n// Define the STLMesh class.\nclass _STLMesh {\n\tprivate _vertices: Float32Array;\n\treadonly faceNormals: Float32Array;\n\tprivate _edgeIndices?: Uint32Array;\n\treadonly faceColors?: Float32Array;\n\tprivate _facesIndices?: Uint32Array;\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\n\tconstructor(data: Buffer | ArrayBuffer | string) {\n\t\tif (typeof data !== 'string') {\n\t\t\tdata = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\t}\n\t\tconst binData = _STLMesh._ensureBinary(data);\n\t\tconst { vertices, faceNormals, faceColors } = _STLMesh._isBinary(binData) ?\n\t\t\t_STLMesh._parseBinary(binData) :\n\t\t\t_STLMesh._parseASCII(_STLMesh._ensureString(data)) as {\n\t\t\t\tvertices: Float32Array;\n\t\t\t\tfaceNormals: Float32Array;\n\t\t\t\tfaceColors?: Float32Array;\n\t\t\t};\n\t\t\n\t\tthis._vertices = vertices;\n\t\tthis.faceNormals = faceNormals;\n\t\tthis.faceColors = faceColors;\n\t}\n\n\t// Parsing code is based on:\n\t// https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/STLLoader.js\n\tprivate static _parseBinary(data: ArrayBuffer) {\n\t\tconst reader = new DataView(data);\n\t\tconst numFaces = reader.getUint32(80, true);\n\n\t\tlet hasColors = false;\n\t\tlet faceColors: Float32Array | undefined;\n\t\tlet defaultR = 0;\n\t\tlet defaultG = 0;\n\t\tlet defaultB = 0;\n\t\t// let alpha: number;\n\n\t\t// Process STL header.\n\t\t// Check for default color in header (\"COLOR=rgba\" sequence).\n\t\tfor (let index = 0; index < 80 - 10; index++) {\n\t\t\tif ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&\n\t\t\t\t(reader.getUint8(index + 4) == 0x52 /*'R'*/) &&\n\t\t\t\t(reader.getUint8(index + 5) == 0x3D /*'='*/)) {\n\n\t\t\t\thasColors = true;\n\t\t\t\tfaceColors = new Float32Array(numFaces * 3);\n\n\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;\n\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;\n\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;\n\t\t\t\t// alpha = reader.getUint8(index + 9) / 255;\n\t\t\t}\n\t\t}\n\n\t\tconst dataOffset = 84;\n\t\tconst faceLength = 12 * 4 + 2;\n\n\t\tconst vertices = new Float32Array(numFaces * 3 * 3);\n\t\tconst faceNormals = new Float32Array(numFaces * 3);\n\n\t\tfor (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {\n\t\t\tconst start = dataOffset + faceIndex * faceLength;\n\t\t\tconst index = 3 * faceIndex;\n\t\t\tfaceNormals[index] = reader.getFloat32(start, true);\n\t\t\tfaceNormals[index + 1] = reader.getFloat32(start + 4, true);\n\t\t\tfaceNormals[index + 2] = reader.getFloat32(start + 8, true);\n\n\t\t\tif (hasColors) {\n\t\t\t\tconst packedColor = reader.getUint16(start + 48, true);\n\t\t\t\tif ((packedColor & 0x8000) === 0) {\n\t\t\t\t\t// facet has its own unique color\n\t\t\t\t\tfaceColors![index] = (packedColor & 0x1F) / 31;\n\t\t\t\t\tfaceColors![index + 1] = ((packedColor >> 5) & 0x1F) / 31;\n\t\t\t\t\tfaceColors![index + 2] = ((packedColor >> 10) & 0x1F) / 31;\n\t\t\t\t} else {\n\t\t\t\t\tfaceColors![index] = defaultR;\n\t\t\t\t\tfaceColors![index + 1] = defaultG;\n\t\t\t\t\tfaceColors![index + 2] = defaultB;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 1; i <= 3; i++) {\n\t\t\t\tconst vertexStart = start + i * 12;\n\t\t\t\tconst componentIndex = (faceIndex * 3 * 3) + ((i - 1) * 3);\n\t\t\t\tvertices[componentIndex] = reader.getFloat32(vertexStart, true);\n\t\t\t\tvertices[componentIndex + 1] = reader.getFloat32(vertexStart + 4, true);\n\t\t\t\tvertices[componentIndex + 2] = reader.getFloat32(vertexStart + 8, true);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvertices,\n\t\t\tfaceNormals,\n\t\t\tfaceColors,\n\t\t};\n\t}\n\n\tprivate static _parseASCII(data: string) {\n\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\tlet faceCounter = 0;\n\n\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\tconst patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n\t\tconst patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n\n\t\tconst vertices: number[] = [];\n\t\tconst faceNormals: number[] = [];\n\n\t\tlet result;\n\n\t\twhile ((result = patternSolid.exec(data)) !== null) {\n\t\t\tconst solid = result[0];\n\n\t\t\twhile ((result = patternFace.exec(solid)) !== null ) {\n\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\tconst text = result[0];\n\n\t\t\t\twhile ((result = patternNormal.exec(text)) !== null) {\n\t\t\t\t\t// every face have to own ONE valid normal\n\t\t\t\t\tif (normalCountPerFace > 0) throw new Error('stl-parser: Something isn\\'t right with the normal of face number ' + faceCounter);\n\t\t\t\t\tfaceNormals.push(\n\t\t\t\t\t\tparseFloat(result[1]),\n\t\t\t\t\t\tparseFloat(result[2]),\n\t\t\t\t\t\tparseFloat(result[3]),\n\t\t\t\t\t);\n\t\t\t\t\tnormalCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\twhile ((result = patternVertex.exec(text)) !== null) {\n\t\t\t\t\tvertices.push(\n\t\t\t\t\t\tparseFloat(result[1]),\n\t\t\t\t\t\tparseFloat(result[2]),\n\t\t\t\t\t\tparseFloat(result[3]),\n\t\t\t\t\t);\n\t\t\t\t\tvertexCountPerFace++;\n\t\t\t\t}\n\t\t\t\t// Each face have to own THREE valid vertices\n\t\t\t\t/* c8 ignore next 3 */\n\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\t\t\t\t\tthrow new Error('stl-parser: Something isn\\'t right with the vertices of face number ' + faceCounter);\n\t\t\t\t}\n\n\t\t\t\tfaceCounter++;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tvertices: new Float32Array(vertices),\n\t\t\tfaceNormals: new Float32Array(faceNormals),\n\t\t};\n\t}\n\n\tprivate static _matchDataViewAt(query: number[], reader: DataView, offset: number) {\n\t\t// Check if each byte in query matches the corresponding byte from the current offset.\n\t\tfor (let i = 0, il = query.length; i < il; i++) {\n\t\t\tif (query[i] !== reader.getUint8(offset + i)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _isBinary(data: ArrayBuffer) {\n\t\tconst reader = new DataView(data);\n\t\tconst face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n\t\tconst n_faces = reader.getUint32(80, true);\n\t\tconst expect = 80 + (32 / 8) + (n_faces * face_size);\n\t\tif (expect === reader.byteLength) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\t\tconst solid = [115, 111, 108, 105, 100];\n\t\tfor (let offset = 0; offset < 5; offset++) {\n\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\t\t\tif (_STLMesh._matchDataViewAt(solid, reader, offset)) return false;\n\t\t}\n\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\t\treturn true;\n\t}\n\n\tprivate static _ensureBinary(buffer: ArrayBuffer | string) {\n\t\tif (typeof buffer === 'string') {\n\t\t\tconst array_buffer = new Uint8Array(buffer.length);\n\t\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian.\n\t\t\t}\n\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t} else {\n\t\t\treturn buffer;\n\t\t}\n\t}\n\n\tprivate static _ensureString(buffer: ArrayBuffer | string) {\n\t\tif (typeof buffer !== 'string') {\n\t\t\treturn new TextDecoder().decode(buffer);\n\t\t}\n\t\treturn buffer;\n\t}\n\n\tget vertices() {\n\t\treturn this._vertices;\n\t}\n\n\tset vertices(vertices: Float32Array) {\n\t\tthrow new Error(`stl-parser: No vertices setter.`);\n\t}\n\n\tget facesIndices() {\n\t\tif (!this._facesIndices) throw new Error(`stl-parser: STL vertices are non-indexed by default, call STLMesh.mergeVertices() before trying to access facesIndices.`);\n\t\treturn this._facesIndices;\n\t}\n\n\tset facesIndices(facesIndices: Uint32Array) {\n\t\tthrow new Error(`stl-parser: No facesIndices setter.`);\n\t}\n\n\t/**\n\t * Merge coincident vertices and index faces.\n\t */\n\tmergeVertices() {\n\t\tconst {\n\t\t\tverticesMerged,\n\t\t\tfacesIndexed,\n\t\t} = mergeVertices(this);\n\t\tthis._vertices = new Float32Array(verticesMerged);\n\t\tthis._facesIndices = facesIndexed;\n\t\tdelete this._edgeIndices; // Invalidate previously calculated edges.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the edges in the stl data (without duplicates).\n\t */\n\tget edgeIndices() {\n\t\tif (!this._edgeIndices) {\n\t\t\tconst { _facesIndices } = this;\n\t\t\tlet edgeIndices: Uint32Array;\n\t\t\tif (_facesIndices) {\n\t\t\t\t// Handle edges on indexed faces.\n\t\t\t\tedgeIndices = new Uint32Array(calcEdgeIndicesFromIndexedFaces(this));\n\t\t\t} else {\n\t\t\t\t// Vertices are grouped in sets of three to a face.\n\t\t\t\tedgeIndices = calcEdgeIndicesFromNonIndexedFaces(this);\n\t\t\t}\n\t\t\tthis._edgeIndices = edgeIndices; // Cache result.\n\t\t}\n\t\treturn this._edgeIndices;\n\t}\n\n\tset edgeIndices(edgeIndices: Uint32Array) {\n\t\tthrow new Error(`stl-parser: No edgeIndices setter.`);\n\t}\n\n\t/**\n\t * Returns the bounding box of the mesh.\n\t */\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\t // Cache result.\n\t\t\tthis._boundingBox = calcBoundingBox(this);\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`stl-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Scales vertex positions (in place) to unit bounding box and centers around origin.\n\t */\n\tscaleVerticesToUnitBoundingBox() {\n\t\t// Scale vertices to bounding box (in place).\n\t\tscaleVerticesToUnitBoundingBox(this);\n\t\tdelete this._boundingBox; // Invalidate previously calculated bounding box.\n\t\treturn this;\n\t}\n}","import { makeEdgeHash } from './index-utils';\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgeIndicesFromNestedIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = facesIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgeIndicesFromIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edgeIndices = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = facesIndices[3 * i + j];\n            const index2 = facesIndices[3 * i + (j + 1) % 3];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edgeIndices.push(index1, index2);\n            }\n        }\n    }\n    return edgeIndices;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgeIndicesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices, uvs, vertexNormals, vertexColors } = mesh;\n    const numFaces = vertices.length / 9;\n    const previousIndexMap = []; // Map from old vertex index to new vertex index.\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 3 * i + j;\n            const positionX = vertices[3 * vertexIndex];\n            const positionY = vertices[3 * vertexIndex + 1];\n            const positionZ = vertices[3 * vertexIndex + 2];\n            let key = `${positionX},${positionY},${positionZ}`;\n            if (uvs) {\n                const uvX = uvs[2 * vertexIndex];\n                const uvY = uvs[2 * vertexIndex + 1];\n                key += `|${uvX},${uvY}`;\n            }\n            if (vertexNormals) {\n                const normalX = vertexNormals[3 * vertexIndex];\n                const normalY = vertexNormals[3 * vertexIndex + 1];\n                const normalZ = vertexNormals[3 * vertexIndex + 2];\n                key += `|${normalX},${normalY},${normalZ}`;\n            }\n            if (vertexColors) {\n                const colorR = vertexColors[3 * vertexIndex];\n                const colorG = vertexColors[3 * vertexIndex + 1];\n                const colorB = vertexColors[3 * vertexIndex + 2];\n                key += `|${colorR},${colorG},${colorB}`;\n            }\n            const faceIndex = 3 * i;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = previousIndexMap.length;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                previousIndexMap.push(vertexIndex);\n            }\n        }\n    }\n    const numMergedVertices = previousIndexMap.length;\n    const verticesMerged = new Float32Array(numMergedVertices * 3);\n    for (let i = 0; i < numMergedVertices; i++) {\n        const previousIndex = previousIndexMap[i];\n        verticesMerged[3 * i] = vertices[3 * previousIndex];\n        verticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n        verticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n    }\n    let uvsMerged;\n    if (uvs) {\n        uvsMerged = new Float32Array(numMergedVertices * 2);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            uvsMerged[2 * i] = uvs[2 * previousIndex];\n            uvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n        }\n    }\n    let vertexNormalsMerged;\n    if (vertexNormals) {\n        vertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n            vertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n            vertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n        }\n    }\n    let vertexColorsMerged;\n    if (vertexColors) {\n        vertexColorsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n            vertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n            vertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n        }\n    }\n    return {\n        verticesMerged,\n        uvsMerged,\n        vertexNormalsMerged,\n        vertexColorsMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=geometry-utils.js.map"],"names":["makeEdgeHash","index1","index2","Math","min","max","parseSTL","data","_STLMesh","loadSTL","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","Uint8Array","binData","_ensureBinary","vertices","faceNormals","faceColors","_isBinary","_parseBinary","_parseASCII","_ensureString","this","_vertices","static","DataView","numFaces","getUint32","hasColors","defaultR","defaultG","defaultB","index","getUint8","Float32Array","faceIndex","start","getFloat32","packedColor","getUint16","i","vertexStart","componentIndex","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","exec","solid","vertexCountPerFace","normalCountPerFace","text","Error","push","parseFloat","query","offset","il","length","byteLength","_matchDataViewAt","array_buffer","charCodeAt","TextDecoder","decode","facesIndices","_facesIndices","mergeVertices","verticesMerged","facesIndexed","uvs","vertexNormals","vertexColors","previousIndexMap","Uint32Array","vertexHash","j","vertexIndex","key","mergedVertexIndex","undefined","numMergedVertices","previousIndex","uvsMerged","vertexNormalsMerged","vertexColorsMerged","_edgeIndices","edgeIndices","edgesHash","calcEdgeIndicesFromIndexedFaces","edges","edgeIndex","calcEdgeIndicesFromNonIndexedFaces","boundingBox","_boundingBox","numVertices","Infinity","calcBoundingBox","scaleVerticesToUnitBoundingBox","target","diff","center","scale","numNodes","Promise","resolve"],"mappings":"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"}